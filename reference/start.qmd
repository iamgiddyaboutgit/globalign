# start { #globalign.start }

`start`



## Classes

| Name | Description |
| --- | --- |
| [SimpleScoringSettings](#globalign.start.SimpleScoringSettings) | Keep things simple to avoid conflicts |

### SimpleScoringSettings { #globalign.start.SimpleScoringSettings }

```python
start.SimpleScoringSettings(
    match_score=2,
    mismatch_score=-3,
    gap_open_score=-4,
    gap_extension_score=-2,
)
```

Keep things simple to avoid conflicts

such as when a custom scoring matrix is used.

## Functions

| Name | Description |
| --- | --- |
| [check_big_main_diag](#globalign.start.check_big_main_diag) | Check if each row of a matrix has its maximum  |
| [check_seq_lengths](#globalign.start.check_seq_lengths) | Check that the product of the lengths of the sequences is |
| [check_symmetric](#globalign.start.check_symmetric) | Check if a matrix is symmetric. |
| [costing_mat_to_scoring_mat](#globalign.start.costing_mat_to_scoring_mat) | Get a scoring matrix from a costing matrix. |
| [draw_random_seq](#globalign.start.draw_random_seq) | Raises: |
| [draw_two_random_seqs](#globalign.start.draw_two_random_seqs) | Args: |
| [get_max_val](#globalign.start.get_max_val) | Get the max value inside a nested dictionary. |
| [make_3d_array](#globalign.start.make_3d_array) | See: https://www.freecodecamp.org/news/list-within-a-list-in-python-initialize-a-nested-list/ |
| [make_matrix](#globalign.start.make_matrix) | Make a matrix as a nested list. |
| [read_first_2_seqs_from_fasta](#globalign.start.read_first_2_seqs_from_fasta) | Returns: |
| [read_scoring_mat](#globalign.start.read_scoring_mat) | Read in scoring matrix. |
| [read_seq_from_fasta](#globalign.start.read_seq_from_fasta) | Read in a FASTA file.  |
| [scoring_mat_to_costing_mat](#globalign.start.scoring_mat_to_costing_mat) | Get a valid cost matrix from a scoring matrix. |
| [validate_and_transform_args](#globalign.start.validate_and_transform_args) | Validates the command line arguments |
| [validate_scoring_mat_keys](#globalign.start.validate_scoring_mat_keys) | Check that the scoring_mat_keys include |

### check_big_main_diag { #globalign.start.check_big_main_diag }

```python
start.check_big_main_diag(mat)
```

Check if each row of a matrix has its maximum 
in the main diagonal entry.

Args:
    mat: nested dictionary representing a matrix

Returns:
    True if each row of mat has its maximum 
    in the main diagonal entry; otherwise, False.

### check_seq_lengths { #globalign.start.check_seq_lengths }

```python
start.check_seq_lengths(seq_1, seq_2, max_seq_len_prod)
```

Check that the product of the lengths of the sequences is

reasonable, i.e. positive and less than max_seq_len_prod.

Raises:
    RuntimeError

### check_symmetric { #globalign.start.check_symmetric }

```python
start.check_symmetric(mat)
```

Check if a matrix is symmetric.

Args:
    mat: nested dictionary representing a matrix

Returns:
    True if mat is symmetric and False otherwise.

Raises:
    AttributeError if mat is not a nested dictionary.

### costing_mat_to_scoring_mat { #globalign.start.costing_mat_to_scoring_mat }

```python
start.costing_mat_to_scoring_mat(
    costing_mat,
    max_score,
    delta_d=None,
    delta_i=None,
)
```

Get a scoring matrix from a costing matrix.

Args: 
    costing_mat: Nested dict representation of 
        a distance matrix
    max_score: Max in scoring_mat
    delta_d: amount to increase the cost of a
        horizontal step in the dynamic programming
        matrix. `delta_d + delta_i >= max_score`.
        Default: None.
    delta_i: amount to increase the cost of a
        vertical step in the dynamic programming
        matrix. 
        `delta_d + delta_i >= max_score`.
        Default: None.

Returns:
    Nested dict representation of a scoring matrix

Reference: https://curiouscoding.nl/posts/alignment-scores-transform/

### draw_random_seq { #globalign.start.draw_random_seq }

```python
start.draw_random_seq(alphabet, min_len, max_len, seed)
```

Raises:
    IndexError: If alphabet == [].
    TypeError: If alphabet is not a list with a len() method.
    ValueError: If min_len > max_len or if min_len < 0.

### draw_two_random_seqs { #globalign.start.draw_two_random_seqs }

```python
start.draw_two_random_seqs(
    alphabet,
    min_len_seq_1,
    max_len_seq_1,
    min_len_seq_2,
    max_len_seq_2,
    divergence,
    seed_1=None,
    seed_2=None,
)
```

Args:
    divergence: a number between 0 and 1, inclusive.
        Higher values for divergence will tend
        to make the two sequences more different
        from each other.

### get_max_val { #globalign.start.get_max_val }

```python
start.get_max_val(m)
```

Get the max value inside a nested dictionary.

### make_3d_array { #globalign.start.make_3d_array }

```python
start.make_3d_array(dim_1, dim_2, dim_3, fill_val)
```

See: https://www.freecodecamp.org/news/list-within-a-list-in-python-initialize-a-nested-list/

### make_matrix { #globalign.start.make_matrix }

```python
start.make_matrix(num_rows, num_cols, fill_val)
```

Make a matrix as a nested list.

See: https://www.freecodecamp.org/news/list-within-a-list-in-python-initialize-a-nested-list/

### read_first_2_seqs_from_fasta { #globalign.start.read_first_2_seqs_from_fasta }

```python
start.read_first_2_seqs_from_fasta(fasta_path)
```

Returns:
    (seq_1, seq_2)
Raises:
    RuntimeError

### read_scoring_mat { #globalign.start.read_scoring_mat }

```python
start.read_scoring_mat(scoring_mat_path)
```

Read in scoring matrix.

Raises:
    FileNotFoundError if not scoring_mat_path.is_file().
    RunTimeError if the header row did not have single letters spaced apart.
    RunTimeError if row headers do not match column headers.

### read_seq_from_fasta { #globalign.start.read_seq_from_fasta }

```python
start.read_seq_from_fasta(fasta_path)
```

Read in a FASTA file. 

Raises:
    RuntimeError
Yields:
    2-tuples where the 0th element is the description
    and the 1st element is the sequence

See: NCBI FASTA specification
https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=BlastHelp

### scoring_mat_to_costing_mat { #globalign.start.scoring_mat_to_costing_mat }

```python
start.scoring_mat_to_costing_mat(
    scoring_mat,
    max_score,
    delta_d=None,
    delta_i=None,
)
```

Get a valid cost matrix from a scoring matrix.

The cost matrix will be a valid distance matrix.

Args: 
    scoring_mat: Nested dict representation of 
        a similarity matrix
    max_score: Max in scoring_mat
    delta_d: amount to increase the cost of a
        horizontal step in the dynamic programming
        matrix. `delta_d + delta_i >= max_score`.
        Default: None.
    delta_i: amount to increase the cost of a
        vertical step in the dynamic programming
        matrix. 
        `delta_d + delta_i >= max_score`.
        Default: None.

Returns:
    Nested dict representation of a distance matrix
        whose entries correspond to string edit costs
        for matches and mismatches.

Reference: https://curiouscoding.nl/posts/alignment-scores-transform/

### validate_and_transform_args { #globalign.start.validate_and_transform_args }

```python
start.validate_and_transform_args(
    input_fasta=None,
    output=None,
    seq_1=None,
    seq_2=None,
    scoring_mat_name=None,
    scoring_mat_path=None,
    match_score=None,
    mismatch_score=None,
    mismatch_cost=None,
    gap_open_score=None,
    gap_open_cost=None,
    gap_extension_score=None,
    gap_extension_cost=None,
)
```

Validates the command line arguments

or the arguments that are passed when
the module is imported and its functionality
used that way.

Returns:
    tuple with entries of
        seq_1_validated,
        seq_2_validated,
        scoring_mat_validated,
        costing_mat_validated,
        gap_open_score_validated,
        gap_open_cost_validated,
        output_validated

### validate_scoring_mat_keys { #globalign.start.validate_scoring_mat_keys }

```python
start.validate_scoring_mat_keys(scoring_mat_keys, common_alphabet)
```

Check that the scoring_mat_keys include

a gap '-' and any other necessary letters
(i.e. letters in common_alphabet).